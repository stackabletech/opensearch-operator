---
apiVersion: v1
kind: Secret
metadata:
  name: opensearch-security-config
stringData:
  action_groups.yml: |
    ---
    _meta:
      type: actiongroups
      config_version: 2
  allowlist.yml: |
    ---
    _meta:
      type: allowlist
      config_version: 2

    # Description:
    # enabled - feature flag.
    # if enabled is false, the allowlisting feature is removed.
    # This is like removing the check that checks if an API is allowlisted.
    # This is equivalent to continuing with the usual access control checks, and removing all the code that implements allowlisting.
    # if enabled is true, then all users except SuperAdmin can access only the APIs in requests
    # SuperAdmin can access all APIs.
    # SuperAdmin is defined by the SuperAdmin certificate, which is configured in the opensearch.yml setting: plugins.security.authcz.admin_dn:
    # Refer to the example setting in opensearch.yml.example, and the opendistro documentation to know more about configuring SuperAdmin.
    #
    # requests - map of allowlisted endpoints, and the allowlisted HTTP requests for those endpoints

    config:
      enabled: false
  audit.yml: |
    ---
    _meta:
      type: audit
      config_version: 2

    config:
      # enable/disable audit logging
      enabled: true

      audit:
        # Enable/disable REST API auditing
        enable_rest: true

        # Categories to exclude from REST API auditing
        disabled_rest_categories:
          - AUTHENTICATED
          - GRANTED_PRIVILEGES

        # Enable/disable Transport API auditing
        enable_transport: true

        # Categories to exclude from Transport API auditing
        disabled_transport_categories:
          - AUTHENTICATED
          - GRANTED_PRIVILEGES

        # Users to be excluded from auditing. Wildcard patterns are supported. Eg:
        # ignore_users: ["test-user", "employee-*"]
        ignore_users:
          - kibanaserver
          - xc-*

        # Requests to be excluded from auditing. Wildcard patterns are supported. Eg:
        # ignore_requests: ["indices:data/read/*", "SearchRequest"]
        ignore_requests: []

        # Log individual operations in a bulk request
        resolve_bulk_requests: false

        # Include the body of the request (if available) for both REST and the transport layer
        log_request_body: true

        # Logs all indices affected by a request. Resolves aliases and wildcards/date patterns
        resolve_indices: true

        # Exclude sensitive headers from being included in the logs. Eg: Authorization
        exclude_sensitive_headers: true

      compliance:
        # enable/disable compliance
        enabled: true

        # Log updates to internal security changes
        internal_config: true

        # Log external config files for the node
        external_config: false

        # Log only metadata of the document for read events
        read_metadata_only: true

        # Map of indexes and fields to monitor for read events. Wildcard patterns are supported for both index names and fields. Eg:
        # read_watched_fields: {
        #   "twitter": ["message"]
        #   "logs-*": ["id", "attr*"]
        # }
        read_watched_fields: {}

        # List of users to ignore for read events. Wildcard patterns are supported. Eg:
        # read_ignore_users: ["test-user", "employee-*"]
        read_ignore_users:
          - kibanaserver

        # Log only metadata of the document for write events
        write_metadata_only: true

        # Log only diffs for document updates
        write_log_diffs: false

        # List of indices to watch for write events. Wildcard patterns are supported
        # write_watched_indices: ["twitter", "logs-*"]
        write_watched_indices: []

        # List of users to ignore for write events. Wildcard patterns are supported. Eg:
        # write_ignore_users: ["test-user", "employee-*"]
        write_ignore_users:
          - kibanaserver
  config.yml: |
    ---

    # This is the main OpenSearch Security configuration file where authentication
    # and authorization is defined.
    #
    # You need to configure at least one authentication domain in the authc of this file.
    # An authentication domain is responsible for extracting the user credentials from
    # the request and for validating them against an authentication backend like Active Directory for example.
    #
    # If more than one authentication domain is configured the first one which succeeds wins.
    # If all authentication domains fail then the request is unauthenticated.
    # In this case an exception is thrown and/or the HTTP status is set to 401.
    #
    # After authentication authorization (authz) will be applied. There can be zero or more authorizers which collect
    # the roles from a given backend for the authenticated user.
    #
    # Both, authc and auth can be enabled/disabled separately for REST and TRANSPORT layer. Default is true for both.
    #        http_enabled: true
    #        transport_enabled: true
    #
    # For HTTP it is possible to allow anonymous authentication. If that is the case then the HTTP authenticators try to
    # find user credentials in the HTTP request. If credentials are found then the user gets regularly authenticated.
    # If none can be found the user will be authenticated as an "anonymous" user. This user has always the username "anonymous"
    # and one role named "anonymous_backendrole".
    # If you enable anonymous authentication all HTTP authenticators will not challenge.
    #
    #
    # Note: If you define more than one HTTP authenticators make sure to put non-challenging authenticators like "proxy" or "clientcert"
    # first and the challenging one last.
    # Because it's not possible to challenge a client with two different authentication methods (for example
    # Kerberos and Basic) only one can have the challenge flag set to true. You can cope with this situation
    # by using pre-authentication, e.g. sending a HTTP Basic authentication header in the request.
    #
    # Default value of the challenge flag is true.
    #
    #
    # HTTP
    #   basic (challenging)
    #   proxy (not challenging, needs xff)
    #   kerberos (challenging)
    #   clientcert (not challenging, needs https)
    #   jwt (not challenging)
    #   host (not challenging) #DEPRECATED, will be removed in a future version.
    #                          host based authentication is configurable in roles_mapping

    # Authc
    #   internal
    #   noop
    #   ldap

    # Authz
    #   ldap
    #   noop

    _meta:
      type: config
      config_version: 2

    config:
      dynamic:
        http:
          anonymous_auth_enabled: false
        authc:
          basic_internal_auth_domain:
            description: Authenticate via HTTP Basic against internal users database
            http_enabled: true
            transport_enabled: true
            order: 1
            http_authenticator:
              type: basic
              challenge: true
            authentication_backend:
              type: intern
          jwt_auth_domain:
            description: Authenticate via Json Web Token
            http_enabled: true
            transport_enabled: true
            order: 0
            http_authenticator:
              type: jwt
              challenge: false
              config:
                signing_key: Uzhpcm5HOERUZ2JIbllpQVFTOEJiZ2c0Z0M1WjJRVjQ=
                jwt_header: Authorization
                jwt_url_parameter: null
                subject_key: username
                roles_key: roles
                required_audience: egp
                required_issuer: atruvia.de
                jwt_clock_skew_tolerance_seconds: 30
            authentication_backend:
              type: noop
        authz: {}
  internal_users.yml: |
    ---
    # This is the internal user database
    # The hash value is a bcrypt hash and can be generated with plugin/tools/hash.sh

    _meta:
      type: internalusers
      config_version: 2

    admin:
      hash: $2y$10$xRtHZFJ9QhG9GcYhRpAGpufCZYsk//nxsuel5URh0GWEBgmiI4Q/e
      reserved: true
      backend_roles:
        - admin
      description: OpenSearch admin user

    kibanaserver:
      hash: $2y$10$vPgQ/6ilKDM5utawBqxoR.7euhVQ0qeGl8mPTeKhmFT475WUDrfQS
      reserved: true
      description: OpenSearch Dashboards user

    prometheusexporter:
      hash: $2y$10$KuE/wuBeN4VGqHcnmL1BS.9iJESdy.avghTln10ZbA887soo4XnLK
      reserved: true
      description: Prometheus exporter user
  nodes_dn.yml: |
    ---
    _meta:
      type: nodesdn
      config_version: 2
  roles.yml: |
    ---
    _meta:
      type: roles
      config_version: 2

    # Allows users to monitor the cluster
    monitoring:
      reserved: true
      cluster_permissions:
        - cluster_monitor
        - cluster:admin/repository/get
      index_permissions:
        - index_patterns:
            - "*"
          allowed_actions:
            - indices:admin/aliases/get
            - indices:admin/mappings/get
            - indices:monitor/settings/get
            - indices:monitor/stats
  roles_mapping.yml: |
    ---
    # In this file users, backendroles and hosts can be mapped to Security roles.
    # Permissions for OpenSearch roles are configured in roles.yml

    _meta:
      type: rolesmapping
      config_version: 2

    all_access:
      reserved: false
      backend_roles:
        - admin
      description: Maps admin to all_access

    own_index:
      reserved: false
      users:
        - "*"
      description: Allow full access to an index named like the username

    monitoring:
      reserved: false
      users:
        - prometheusexporter

    kibana_server:
      reserved: true
      users:
        - kibanaserver
  tenants.yml: |
    ---
    _meta:
      type: tenants
      config_version: 2
  whitelist.yml: |
    ---
    _meta:
      type: whitelist
      config_version: 2

    config:
      enabled: false
